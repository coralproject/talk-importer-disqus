#!/usr/bin/env node

const Disqus = require('./disqus');
const TalkService = require('./talk-service');

class Sponge {

  constructor(strategy) {
    this.strategy = strategy;
    this.disqus = new Disqus(strategy.service);
    this.talk = new TalkService(strategy.service.url);
  }

  async translate(post, model) {
      let c = {};
      let fields = this.strategy.map.entities[model].fields;

      for (let field in fields) {
        await this.transform_field(post, fields[field], this.strategy.name)
        .then((value) => {
          c[field] = value;
        })
        .catch((error) => {
          console.log('Error when transforming field ', field, error);
        });
      }

      return this.talk.createComment(c).then((comment) => {
        // To Do: once is created it needs to add any flags to the actions
        // Look if it is flagged
        if (comment.metadata.isFlagged) {
          let action = {};

          action.action_type = 'FLAG';
          action.item_type = 'COMMENTS';
          action.item_id = comment.id;
          action.user_id = null;
          action.group_id = 'Other';
          action.metadata = { 'message': 'Disqus'};

          this.talk.createAction(action);
        }
      });
  }

  async transform_field(old_comment, field, source_name) {
    switch(field.relation) {
    case 'Identity':
      return new Promise((resolve, reject) => {
        let value = this.get_value(old_comment, field);
        if (value == undefined) {
          return reject(`Did not found value for field ${field.source}.`);
        }
        return resolve(value);
      });

    case 'FindOrCreateUser':
      return new Promise((resolve, reject) => {
        let user_id = this.transform_user(old_comment[field.source], field.map.fields, source_name);
        if (user_id == undefined) {
          return reject('Error on getting user field.');
        }
        return resolve(user_id);
      });

    case 'FindOrCreateAsset':
    
      let old_asset = await this.disqus.get_asset(old_comment[field.source]);
      let asset_id = await this.create_asset(old_asset.response, field.map.fields, source_name);

      return new Promise((resolve, reject) => {
        if (asset_id == undefined) {
          return reject('Error on getting asset field.');
        }
        return resolve(asset_id);
      });

    case 'Status':
      return new Promise((resolve, reject) => {
        let value = this.get_value(old_comment, field);
        if (value == undefined) {
          return reject(`Error getting the status value for ${field.source}`);
        }
        return resolve(field['status'][value]);
      });

    case 'Parent':  
      let parent_id = this.create_parent(old_comment, field);
      return new Promise((resolve, reject) => {
        if (parent_id == undefined) {
          return reject('Error on getting parent_id field.');
        }
        return resolve(parent_id);
      });

    case 'Metadata':
      return new Promise((resolve, reject) => {
        let value = this.get_metadata(old_comment, field);
        if (value == undefined) {
          return reject('Error on getting metadata field.');
        }
        return resolve(value);
      });
    default:
      return new Promise((reject) => {
        return reject('Relation not found.');
      });
    }
  }

  get_value(old_comment, field) {
    return old_comment[field.source];
  }

  get_metadata(old_comment, field) {
    let metadata = {};
    for (let f of field['fields']) {
      metadata[f['name']] = this.get_value(old_comment, f);
    }
    return metadata;
  }

  async transform_user(old_user, fields, source_name) {
    let u = {}
    for (let f in fields) {
      u[f] = await this.transform_field(old_user, fields[f], source_name)
      .catch((error) => {
        console.log(`error ${error}`);
      });
    }

    // Provider set the profile that will be disqus for all this
    u['provider'] = 'Disqus';
    let username = u.displayName.replace(/ /g, '_').replace(/[^a-zA-Z_]/g, '');
    u['id'] = `${username}@fromdisqus.com`;

    // {id, provider, displayName} in the user
    return this.talk.createUser(u)
    .then((user) => {
      if (user != undefined) {
        return user.id;
      }
      console.log('Error as returned undefined user.')
    })
    .catch((error) => {
      console.log('Error ', error);
    });
  }

  async create_asset(old_asset, fields, source_name) {
    let promises = [];
    let a = {};
    for (let f in fields) {
      a[f] = await this.transform_field(old_asset, fields[f], source_name);
    }

    let asset = await this.talk.createAsset(a);
    return asset.id;
  }

  create_parent(old_comment, field) {
      return this.talk.findComment(this.get_value(old_comment,field.search_field))
      .then((comment) => {
        if (comment == null) {
          return null;
        } 
        return comment.id;
      })
      .catch((error) => {
        console.log('Error finding the parent comment ', error);
        return null;
      });
  }

}

module.exports = Sponge;