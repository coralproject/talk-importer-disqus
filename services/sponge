#!/usr/bin/env node

const commentService = require('../services/talk/services/comments');
const userService = require('../services/talk/services/users');
const assetService = require('../services/talk/services/assets');

const Disqus = require('./disqus');

class Sponge {

  constructor(strategy) {
    this.strategy = strategy;
    this.disqus = new Disqus(strategy.service);
  }

  async translate(post, model) {

      let c = {};
      let fields = this.strategy.map.entities[model].fields;

      for (let field in fields) {
        c[field] = await this.transform_field(post, fields[field], this.strategy.name);
      }
      let comment = commentService.create(c);
  
      // It helps to normalize and clean the comment object.
      return comment.get();
  }

  async transform_field(old_comment, field, source_name) {
    switch(field.relation) {
    case 'Identity':
      return new Promise((resolve, reject) => {
        let value = this.get_value(old_comment, field);
        if (value == undefined) {
          reject('Error on getting identity value.');
        }
        resolve(value);
      });

    case 'FindOrCreateUser':
      return new Promise((resolve, reject) => {
        let user = this.transform_user(old_comment[field.source], field.map.fields, source_name);
        if (user == undefined) {
          return reject('Error on getting user field.');
        }
        return resolve(user.id);
      });

    case 'FindOrCreateAsset':
    
      let old_asset = await this.disqus.get_asset(old_comment[field.source]);
      let asset = this.create_asset(old_asset.response, field.map.fields, source_name);
      return new Promise((resolve, reject) => {
        // get the asset information for old_comment[field.source]
        if (asset == undefined) {
          return reject('Error on getting asset field.');
        }
        return resolve(asset);
      });

    case 'Status':
      return new Promise((resolve) => {
        return resolve(field['status'][this.get_value(old_comment, field)]);
      });

    case 'Parent':  
      return new Promise((resolve, reject) => {
        let comment = commentService.create(this.get_value(old_comment, field))
        if (comment == undefined) {
          return reject('Error on getting comment field.');
        }
        return resolve(comment);
      });

    case 'Metadata':
      return new Promise((resolve) => {
        return resolve(this.get_metadata(old_comment, field));
      });
    default:
      return new Promise((reject) => {
        return reject('Relation not found.');
      });
    }
  }

  get_value(old_comment, field) {
    return old_comment[field.source];
  }

  get_metadata(old_comment, field) {
    let metadata = {};
    for (let f of field['fields']) {
      metadata[f['name']] = this.get_value(old_comment, f);
    }
    return metadata;
  }

  async transform_user(old_user, fields, source_name) {
    let u = {}
    for (let f in fields) {
      u[f] = await this.transform_field(old_user, fields[f], source_name);
    }
    u['provider'] = 'Disqus';
    let user = userService.findOrCreateExternalUser(u)
    return user;
  }

  async create_asset(old_asset, fields, source_name) {
    let a = {}
    for (let f in fields) {
      a[f] = await this.transform_field(old_asset, fields[f], source_name);
    }

    let asset = assetService.findOrCreateByUrl(a.url);
    return asset.get();
  }

}

module.exports = Sponge;