#!/usr/bin/env node

const Disqus = require('./disqus');
const TalkService = require('./talk-service');

class Sponge {

  constructor(strategy) {
    this.strategy = strategy;
    this.disqus = new Disqus(strategy.service);
    this.talk = new TalkService();
  }

  async translate(post, model) {

      let c = {};
      let fields = this.strategy.map.entities[model].fields;

      for (let field in fields) {
        await this.transform_field(post, fields[field], this.strategy.name)
        .then((value) => {
          c[field] = value;
        })
        .catch((error) => {
          console.log('Error when transforming field ', field, error);
        });
      }

      return this.talk.createComment(c);
  }

  async transform_field(old_comment, field, source_name) {
    switch(field.relation) {
    case 'Identity':
      return new Promise((resolve, reject) => {
        let value = this.get_value(old_comment, field);
        if (value == undefined) {
          reject('Error on getting identity value.');
        }
        resolve(value);
      });

    case 'FindOrCreateUser':
      return new Promise((resolve, reject) => {
        let user = this.transform_user(old_comment[field.source], field.map.fields, source_name);
        if (user == undefined) {
          return reject('Error on getting user field.');
        }
        return resolve(user.id);
      });

    case 'FindOrCreateAsset':
    
      let old_asset = await this.disqus.get_asset(old_comment[field.source]);
      let asset_id = this.create_asset(old_asset.response, field.map.fields, source_name);
      return new Promise((resolve, reject) => {
        if (asset_id == undefined) {
          return reject('Error on getting asset field.');
        }
        return resolve(asset_id);
      });

    case 'Status':
      return new Promise((resolve) => {
        return resolve(field['status'][this.get_value(old_comment, field)]);
      });

    case 'Parent':  
      let parent_id = this.create_parent(old_comment, field);
      return new Promise((resolve, reject) => {
        if (parent_id == undefined) {
          return reject('Error on getting parent_id field.');
        }
        return resolve(parent_id);
      });

    case 'Metadata':
      return new Promise((resolve) => {
        return resolve(this.get_metadata(old_comment, field));
      });
    default:
      return new Promise((reject) => {
        return reject('Relation not found.');
      });
    }
  }

  get_value(old_comment, field) {
    return old_comment[field.source];
  }

  get_metadata(old_comment, field) {
    let metadata = {};
    for (let f of field['fields']) {
      metadata[f['name']] = this.get_value(old_comment, f);
    }
    return metadata;
  }

  async transform_user(old_user, fields, source_name) {
    let u = {}
    for (let f in fields) {
      u[f] = await this.transform_field(old_user, fields[f], source_name);
    }
    u['provider'] = 'Disqus';

    const user = this.talk.createUser(u);

    return user.id;
  }

  async create_asset(old_asset, fields, source_name) {
    let a = {}
    for (let f in fields) {
      a[f] = await this.transform_field(old_asset, fields[f], source_name);
    }

    let asset = this.talk.createAsset(a);
    return asset.id;
  }

  create_parent(old_comment, field) {
      return this.talk.findComment(this.get_value(old_comment,field.search_field))
      .then((comment) => {
        if (comment == null) {
          return null;
        } 
        return comment.id;
      })
      .catch((error) => {
        console.log('Error finding the parent comment ', error);
        return null;
      });
      
      // let parent = this.talk.createComment(this.get_value(old_comment, field));
      // return parent.id
  }

}

module.exports = Sponge;